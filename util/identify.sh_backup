#!/usr/bin/env bash
#
# This script will conduct astrometric calibration of an image. It may also identify a star using this calibrated image.
#
# ERROR_STATUS indicates error conditions
# 0 - OK
# 1 - field not solved, no need to retry
# 2 - possible server communication error, retry with another plate solve server
ERROR_STATUS=0

# Decide if we want to use local installation of Astrometry.net software or a remote one
#ASTROMETRYNET_LOCAL_OR_REMOTE="remote"
# Check the default Astrometry.net install location
if [ -d /usr/local/astrometry/bin ];then
 export PATH=/usr/local/astrometry/bin:$PATH
fi

# if ASTROMETRYNET_LOCAL_OR_REMOTE was not set externally to the script
if [ -z "$ASTROMETRYNET_LOCAL_OR_REMOTE" ];then
 which solve-field &>/dev/null
 if [ $? -eq 0 ];then
  echo "Using the local copy of Astrometry.net software..."
  ASTROMETRYNET_LOCAL_OR_REMOTE="local"
 else
  echo "Using a remote server hosting Astrometry.net software..."
  ASTROMETRYNET_LOCAL_OR_REMOTE="remote"
 fi
fi

#### REMOVE BEFORE PRODUCTION: this is to debug the remote plate solve server access
#ASTROMETRYNET_LOCAL_OR_REMOTE="remote"
####

if [ "$ASTROMETRYNET_LOCAL_OR_REMOTE" = "remote" ];then
 ###################################################
 echo -n "Checking if we can reach any plate solve servers... "
 # Decide on which plate solve server to use
 # first - set the initial list of servers
 PLATE_SOLVE_SERVERS="scan.sai.msu.ru polaris.kirx.net vast.sai.msu.ru"
 rm -f srever_*.ping_ok
 for i in $PLATE_SOLVE_SERVERS ;do
  ping -c1 -n "$i" &>/dev/null && echo "$i" > srever_"$i".ping_ok &
  echo -n "$i "
 done

 wait
 cat srever_*.ping_ok > srevers.ping_ok

 echo "
The reachable servers are:"
 cat srevers.ping_ok

 if [ ! -s srevers.ping_ok ];then
  echo "ERROR: no servers could be reached"
  exit 1
 fi

 # Choose a random server among the available ones
 PLATE_SOLVE_SERVER=`sort --random-sort --random-source=/dev/urandom srevers.ping_ok | sort -R | head -n1`
 # If the above fails because sort doesn't understand the '--random-sort' option
 if [ "$PLATE_SOLVE_SERVER" = "" ];then
  PLATE_SOLVE_SERVER=`head -n1 srevers.ping_ok`
 fi

 # Update the list of available servers
 PLATE_SOLVE_SERVERS=""
 while read SERVER ;do
  PLATE_SOLVE_SERVERS="$PLATE_SOLVE_SERVERS $SERVER"
 done < srevers.ping_ok
 echo "Updated list of available servers: $PLATE_SOLVE_SERVERS"

 rm -f srever_*.ping_ok srevers.ping_ok

 # Check if we are requested to use a specific plate solve server
 if [ ! -z "$FORCE_PLATE_SOLVE_SERVER" ];then
  if [ "$FORCE_PLATE_SOLVE_SERVER" != "none" ];then
   echo "WARNING: using the user-specified plate solve server $FORCE_PLATE_SOLVE_SERVER"
   PLATE_SOLVE_SERVER="$FORCE_PLATE_SOLVE_SERVER"
   PLATE_SOLVE_SERVERS="$PLATE_SOLVE_SERVER"
  fi
 fi

 if [ "$PLATE_SOLVE_SERVER" = "" ];then
  echo "Error choosing the plate solve server"
  exit 1
 fi
 ###################################################

 # Find curl
 CURL=`which curl`
 if [ $? -ne 0 ];then
  echo "ERROR: cannot find curl in PATH"
  exit 1
 else
  # Set max time for all network communications
  # note that this is ALSO acomplished by the timeout command before curl
  # AND at the server side
  CURL="$CURL --max-time 299 "
 fi 

fi # if [ "$ASTROMETRYNET_LOCAL_OR_REMOTE" = "remote" ];then

# Set SExtractor executable
SEXTRACTOR=sex
export PATH=$PATH:lib/bin/

# Determine working mode: star identification or image WCS calibration
START_NAME=`basename $0`
if [ "$START_NAME" = "wcs_image_calibration.sh" ];then
 echo "Entering WCS image calibration mode."
 if [ -z "$1" ]; then
  echo "
Usage: $0 image.fit
 or
       $0 image.fit FIELD_OF_VIEW_IN_ARCMIN"
  exit 1
 fi
 FITSFILE="$1"
 APP=6.0 
else
 echo "Entering star identification mode."
 if [ -z "$1" ]; then
  echo "
Usage: $0 outNUMBER.dat
 or
       $0 outNUMBER.dat FIELD_OF_VIEW_IN_ARCMIN"
  exit 1
 fi
 LIGHTCURVEFILE="$1"
 # Check if that file actually exists
 if [ ! -f "$LIGHTCURVEFILE" ];then
  echo "ERROR: the lightcurve file $LIGHTCURVEFILE does not exist!"
  exit 1
 fi
 # Get the image name from the lightcurve file (first line, last column)
 echo -ne "reading light curve $LIGHTCURVEFILE - "
 read JD MAG MERR X Y APP FITSFILE < $LIGHTCURVEFILE && echo "ok"
 # TRAP!! If we whant to identify a flare, there will be no sence to search for an asteroid on the reference image.
 # Use the first discovery image instead!
 REFERENCE_IMAGE=`cat vast_summary.log |grep "Ref.  image:" | awk '{print $6}'`
 if [ "$START_NAME" = "identify_transient.sh" ];then
  while read JD MAG MERR X Y APP FITSFILE ;do
  if [ "$FITSFILE" != "$REFERENCE_IMAGE" ] ;then 
   break
  fi
  done < $LIGHTCURVEFILE
 fi
fi

# Check if FITSFILE variable is set correctly
if [ -z "$FITSFILE" ];then
 echo "ERROR: FITSFILE variable is not set while it is supposed to be set befor reaching this point in the script."
 exit 1
fi

# Check if the image actually exists
if [ ! -f "$FITSFILE" ];then
 echo "ERROR: cannot fin the image file $FITSFILE"
 exit 1
fi

# Test if the original image is already a calibrated one
# (Test by checking the file name)
TEST_SUBSTRING=`basename $FITSFILE`
TEST_SUBSTRING="${TEST_SUBSTRING:0:4}"
#TEST_SUBSTRING=`expr substr $TEST_SUBSTRING  1 4`
if [ "$TEST_SUBSTRING" = "wcs_" ];then
 cp $FITSFILE .
 WCS_IMAGE_NAME=`basename $FITSFILE`
else
 WCS_IMAGE_NAME=wcs_`basename $FITSFILE`
fi

SEXTRACTOR_CATALOG_NAME="$WCS_IMAGE_NAME".cat

# Check if vast_summary.log file is present
if [ ! -f vast_summary.log ];then
 echo "vast_summary.log not found! Creating a fake one..."
 # Note, we set default.sex.PHOTO instead of default.sex file because the situation when we have
 # a dataset reduced with an old version of vast which does not write the log file is more likely
 # to occur with photographic data
 #echo "SExtractor parameter file: default.sex.PHOTO " > vast_summary.log 
 # No, this was stupid! The data loading script will make sure the proper default.sex file is in the directory!
 echo "SExtractor parameter file: default.sex " > vast_summary.log 
fi


# Parse the command line arguments
if [ -z $2 ];then 
 #FOV=40
 #FOV=62
 #echo "Field of view was not set. Retreating to a default value $FOV'..."
 echo "Field of view for the image $FITSFILE was not set. Trying to guess..."
 FOV=`lib/try_to_guess_image_fov $FITSFILE`
 echo "The guess is $FOV arcmin."
 TEST=`echo "$FOV<15.0"|bc -ql`
 if [ $TEST -eq 1 ];then
  # If we know FOV is so small we have no hope to blindly solve it 
  # - try to rely on WCS information that may be already inserted in the image
  if [ ! -f $WCS_IMAGE_NAME ];then
   # Check if the file already contains a WCS-header
   echo $SEXTRACTOR -c `grep "SExtractor parameter file:" vast_summary.log |awk '{print $4}'` -PARAMETERS_NAME wcs.param -CATALOG_NAME $SEXTRACTOR_CATALOG_NAME -PHOT_APERTURES `lib/autodetect_aperture_main $FITSFILE 2>/dev/null` $FITSFILE 
   $SEXTRACTOR -c `grep "SExtractor parameter file:" vast_summary.log |awk '{print $4}'` -PARAMETERS_NAME wcs.param -CATALOG_NAME $SEXTRACTOR_CATALOG_NAME -PHOT_APERTURES `lib/autodetect_aperture_main $FITSFILE 2>/dev/null` $FITSFILE && echo "Using WCS information from the original image" >>/dev/stderr && cp $FITSFILE $WCS_IMAGE_NAME
  fi
  
 fi # if [ $TEST -eq 1 ];then
else
 FOV=$2
fi

# Now the interesting part...


######## Experimental stuff
## The following code was supposed to be used to check if an image already has usable WCS information in its header
## The sad reality is that this information might be wrong and we have a better chance of solving the image
## blindly rather than relying on the pre-supplied WCS information.
#if [ ! -f $WCS_IMAGE_NAME ];then
# # Check if the file already contains a WCS-header
# echo $SEXTRACTOR -c `grep "SExtractor parameter file:" vast_summary.log |awk '{print $4}'` -PARAMETERS_NAME wcs.param -CATALOG_NAME $SEXTRACTOR_CATALOG_NAME -PHOT_APERTURES `lib/autodetect_aperture_main $FITSFILE 2>/dev/null` $FITSFILE 
# $SEXTRACTOR -c `grep "SExtractor parameter file:" vast_summary.log |awk '{print $4}'` -PARAMETERS_NAME wcs.param -CATALOG_NAME $SEXTRACTOR_CATALOG_NAME -PHOT_APERTURES `lib/autodetect_aperture_main $FITSFILE 2>/dev/null` $FITSFILE && echo "Using WCS information from the original image" >>/dev/stderr && cp $FITSFILE $WCS_IMAGE_NAME
#fi
########


if [ ! -f $WCS_IMAGE_NAME ];then
 echo "No image with WCS calibration found."
 echo -n "Starting SExtractor...  "
 #sex -c `grep "SExtractor parameter file:" vast_summary.log |awk '{print $4}'` -PHOT_APERTURES $APP -CATALOG_NAME out$$.xyls -CATALOG_TYPE FITS_1.0 -PARAMETERS_NAME xylist.param $FITSFILE && echo "ok"
 IMAGE_SIZE=`lib/astrometry/get_image_dimentions $FITSFILE | awk '{print "width="$2" -F hight="$4}'`
 # EXPERIMENTAL STUFF 
 CATALOG_NAME=`lib/fits2cat $FITSFILE`
 if [ -f "$CATALOG_NAME".apphot ];then
  CATALOG_NAME="$CATALOG_NAME".apphot
 fi
 lib/make_outxyls_for_astrometric_calibration "$CATALOG_NAME" out$$.xyls `lib/astrometry/get_image_dimentions $FITSFILE | awk '{print $2" "$4}'`
 #lib/make_outxyls_for_astrometric_calibration `lib/fits2cat $FITSFILE` out$$.xyls `lib/astrometry/get_image_dimentions $FITSFILE | awk '{print $2" "$4}'`
 if [ $? -ne 0 ];then
  echo "ERROR running lib/make_outxyls_for_astrometric_calibration!"
  exit 1
 fi
 if [ ! -f out$$.xyls ];then
  echo "ERROR: out$$.xyls not found!"
  exit 1
 fi
 echo " 
This service uses tools provided by Astrometry.net.
For more details visit http://astrometry.net/ .

Please note, the automatic identification usually works fine with a large field 
of view (say, >40 arcmin). If the images are smaller than 20', the automatic 
field identification have good chances to fail. Sorry... :(
"

# Try to solve the image with a range of trial FOVs

 for TRIAL_FOV in $FOV `echo "3/4*$FOV" | bc -ql | awk '{printf "%.1f",$1}'` `echo "2*$FOV" | bc -ql | awk '{printf "%.1f",$1}'` `echo "10*$FOV" | bc -ql | awk '{printf "%.1f",$1}'` ;do
 
 echo "######### Trying to solve plate assuming $TRIAL_FOV' field of view #########"


 if [ "$ASTROMETRYNET_LOCAL_OR_REMOTE" = "remote" ];then
  # Web-based processing
  while true ;do
   #################### Check if we want to retry with another server ####################
   if [ $ERROR_STATUS -eq 2 ];then
    # Remove the current server from the list
    PLATE_SOLVE_SERVERS=${PLATE_SOLVE_SERVERS//$PLATE_SOLVE_SERVER/}
    # Pick the next server in line
    PLATE_SOLVE_SERVER=`echo $PLATE_SOLVE_SERVERS | awk '{print $1}'`
    # break if there are no more servers left
    if [ "$PLATE_SOLVE_SERVER" = "" ];then
     break
    fi
   fi
   #################### Start of single-server communication ####################
   echo -e "Submitting the plates solving job to the server \033[01;34m $PLATE_SOLVE_SERVER \033[00m"
   echo -e "This may take \033[01;31mup to a few minutes\033[00m..."
   if [ ! -f out$$.xyls ];then
    echo "ERROR: the file out$$.xyls is lost somewhere on the way!"
    exit 1
   fi
   #`lib/find_timeout_command.sh` 300 $CURL -F file=@out$$.xyls -F submit="Upload Image" -F fov=$TRIAL_FOV -F $IMAGE_SIZE "http://$PLATE_SOLVE_SERVER/cgi-bin/process_file/process_sextractor_list.py" --user vast48:khyzbaojMhztNkWd > server_reply$$.html
   # Note that the timeout is also enforced at the server side
   `lib/find_timeout_command.sh` 300 $CURL -F file=@out$$.xyls -F submit="Upload Image" -F fov=$TRIAL_FOV -F $IMAGE_SIZE "http://$PLATE_SOLVE_SERVER/cgi-bin/process_file/process_sextractor_list.py" --user vast48:khyzbaojMhztNkWd > server_reply$$.html
   if [ $? -ne 0 ];then
    echo "An ERROR has occured while uploading the star list to the server!"
    ERROR_STATUS=2
    continue
   fi
   if [ ! -s server_reply$$.html ];then
    echo "ERROR: the server reply is empty!"
    ERROR_STATUS=2
    continue
   fi
   EXPECTED_WCS_HEAD_URL=`grep WCS_HEADER_FILE= server_reply$$.html |awk '{print $2}'`
   if [ "$EXPECTED_WCS_HEAD_URL" = "" ];then
    echo "ERROR: cannot parse the server reply!"
    echo "#### Server reply listing ####"
    cat server_reply$$.html
    echo "##############################"
    ERROR_STATUS=2
    continue
   fi
   echo "#### Plate solution log ####"
   SOLVE_PROGRAM_LOG_URL=${EXPECTED_WCS_HEAD_URL//out.wcs/program.log}
   `lib/find_timeout_command.sh` 300 $CURL "$SOLVE_PROGRAM_LOG_URL" --user vast48:khyzbaojMhztNkWd
   if [ $? != 0 ];then
    echo "ERROR: getting processing log from the server $PLATE_SOLVE_SERVER"
    ERROR_STATUS=2
    continue
   fi
   echo "############################"
   SOLVE_FILE_URL=${EXPECTED_WCS_HEAD_URL//out.wcs/out.solved}
   `lib/find_timeout_command.sh` 300 $CURL "$SOLVE_FILE_URL" --user vast48:khyzbaojMhztNkWd 2>/dev/null |grep "404 Not Found" >/dev/null
   # Nope, this interfers with the if statement below
   #if [ $? -ge 130 ];then
   # # Exit if the process is killed by user
   # exit 1
   #fi
   if [ $? -eq 1 ];then
    echo -e "Field \033[01;32mSOLVED\033[00m =)"
    rm -f out.solved
    echo -n "Downloading WCS header...  "
    `lib/find_timeout_command.sh` 300 $CURL "$EXPECTED_WCS_HEAD_URL" -o out$$.wcs --user vast48:khyzbaojMhztNkWd &>/dev/null  && echo "done"
    # This one should not interfere with the if below
    if [ $? -ge 130 ];then
     # Exit if the process is killed by user
     exit 1
    fi
    if [ -f out$$.wcs ];then
     cp $FITSFILE `basename $FITSFILE`
     echo -n "Inserting WCS header...  "
     lib/astrometry/insert_wcs_header out$$.wcs `basename $FITSFILE`
     if [ $? -ne 0 ];then
      # This is a bad one, just exit
      echo " ERROR inserting WCS header! Aborting further actions! "
      exit 1
     else
      ERROR_STATUS=0
      echo "The WCS header appears to be added with no errors."
     fi
     rm -f `basename $FITSFILE` out$$.wcs
    else
     echo "ERROR: cannot download out.wcs "
     ERROR_STATUS=2
     continue
    fi
   else
    echo -e "Sadly, the field was \033[01;31mNOT SOLVED\033[00m. :("
    echo "Try to set a smaller field of view size, for example:  $0 $1 " `echo "$TRIAL_FOV/2"|bc -ql`
    ERROR_STATUS=1
   fi
   # At this point we should remove the completed job from the server
   SERVER_JOB_ID=`grep "Job ID:" server_reply$$.html |head -n1 |awk '{print $3}'`
   if [ "$SERVER_JOB_ID" != "" ];then
    echo "Sending request to remove job $SERVER_JOB_ID from the server...  "
    VaSTID="XGkbtHTGfTPVLrZLBdtIDPzGAEAjaZWW"
    # Web-based processing - remove completed plate-solveing job from the server
    `lib/find_timeout_command.sh` 300 $CURL -F JobID="$SERVER_JOB_ID" -F VaSTID=$VaSTID "http://$PLATE_SOLVE_SERVER/cgi-bin/process_file/remove_job.py" --user vast48:khyzbaojMhztNkWd 
    if [ $? -ne 0 ];then
     echo "Hmm... Some error?"
    fi
   else
    echo "ERROR: cannot get Job ID from server_reply$$.html"
    cat server_reply$$.html
   fi
   rm -f server_reply$$.html #out$$.xyls
   #################### End of single-server communication ####################
   # Check exit conditions
   if [ $ERROR_STATUS -eq 0 ];then
    break
   fi
   if [ $ERROR_STATUS -eq 1 ];then
    break
   fi
   ############################################################################
  done
 fi # if [ "$ASTROMETRYNET_LOCAL_OR_REMOTE" = "remote" ];then
 
 ############################################################################
 # Local plate-solving software
 if [ "$ASTROMETRYNET_LOCAL_OR_REMOTE" = "local" ];then
  IMAGE_SIZE=`lib/astrometry/get_image_dimentions $FITSFILE`
  SCALE_LOW=`echo "0.9*$TRIAL_FOV" | bc -ql`
  SCALE_HIGH=`echo "5.0*$TRIAL_FOV" | bc -ql`
  #`lib/find_timeout_command.sh` 180 solve-field --continue --no-plots --x-column X_IMAGE --y-column Y_IMAGE --sort-column FLUX_APER $IMAGE_SIZE --scale-units arcminwidth --scale-low $SCALE_LOW --scale-high $SCALE_HIGH  out$$.xyls
  #echo `lib/find_timeout_command.sh` 180 solve-field --overwrite --no-plots --x-column X_IMAGE --y-column Y_IMAGE --sort-column FLUX_APER $IMAGE_SIZE --scale-units arcminwidth --scale-low $SCALE_LOW --scale-high $SCALE_HIGH  out$$.xyls
  # --ra '18:53:15.282' --dec '-00:03:52.225' --radius '1.0'
  #`lib/find_timeout_command.sh` 180 solve-field  --overwrite --no-plots --x-column X_IMAGE --y-column Y_IMAGE --sort-column FLUX_APER $IMAGE_SIZE --scale-units arcminwidth --scale-low $SCALE_LOW --scale-high $SCALE_HIGH  out$$.xyls
  `lib/find_timeout_command.sh` 600 solve-field  --overwrite --no-plots --x-column X_IMAGE --y-column Y_IMAGE --sort-column FLUX_APER $IMAGE_SIZE --scale-units arcminwidth --scale-low $SCALE_LOW --scale-high $SCALE_HIGH  out$$.xyls
  if [ $? -ge 130 ];then
   # Exit if solve-field was killed by user
   exit 1
  fi
  if [ $? -ne 0 ];then
   echo "ERROR running solve-field!"
   continue
   #exit 1
  fi
  if [ ! -f out$$.solved ];then
   echo "The field could not be sloved :("
   continue
   #exit 1
  fi
  if [ -f out$$.wcs ];then
   cp $FITSFILE `basename $FITSFILE`
   echo -n "Inserting WCS header...  "
   lib/astrometry/insert_wcs_header out$$.wcs `basename $FITSFILE`
   if [ $? -ne 0 ];then
    # This is a bad one, just exit
    echo " ERROR inserting WCS header! Aborting further actions! "
    exit 1
   else   
    ERROR_STATUS=0
    echo "The WCS header appears to be added with no errors."
   fi
   # clean up
   rm -f `basename $FITSFILE` out$$.wcs out$$.axy out$$.corr out$$.match out$$.rdls out$$.solved out$$.xyls out$$-indx.xyls
  else
   echo "ERROR: cannot find out$$.wcs "
   ERROR_STATUS=2
  fi
  # Clean-up
  #cp out*.xyls /tmp/
  rm -f out*.axy out*.xyls
  # end of clean-up
 fi # if [ "$ASTROMETRYNET_LOCAL_OR_REMOTE" = "local" ];then
 ############################################################################
 
 # if the wcs-calibrated image is created one way or another...
 if [ -f $WCS_IMAGE_NAME ];then
  # Success
  break
 fi
 
 done # for TRIAL_FOV in ...

 ########## Special clean-up for multiple tries with a remote server
 if [ -f out$$.xyls ];then
  #cp out$$.xyls /tmp
  rm -f out$$.xyls
 fi

else
 echo "WCS calibrated image found: $WCS_IMAGE_NAME"
fi

# Check if the wcs-solved image could not be created
if [ ! -f $WCS_IMAGE_NAME ];then
 # Failure
 exit 1
fi

# Check for errors on previous steps
if [ $ERROR_STATUS -ne 0 ];then
 echo "ERROR: $ERROR_STATUS"
 exit $ERROR_STATUS
fi

 # At this point, we should somehow have a WCS calibrated image named $WCS_IMAGE_NAME
 if [ ! -f $SEXTRACTOR_CATALOG_NAME ];then
  echo "Starting SExtractor" >> /dev/stderr
  echo -ne "Starting SExtractor - "
  $SEXTRACTOR -c `grep "SExtractor parameter file:" vast_summary.log |awk '{print $4}'` -PARAMETERS_NAME wcs.param -CATALOG_NAME $SEXTRACTOR_CATALOG_NAME -PHOT_APERTURES `lib/autodetect_aperture_main $WCS_IMAGE_NAME 2>/dev/null` $WCS_IMAGE_NAME && echo "ok"
  echo "Catalog $SEXTRACTOR_CATALOG_NAME corresponding to the image $WCS_IMAGE_NAME created."
 else
  echo "Catalog $SEXTRACTOR_CATALOG_NAME corresponding to the image $WCS_IMAGE_NAME found." 
  
  # Checking the catalog format
  TEST=`head -n1 $SEXTRACTOR_CATALOG_NAME | awk '{print $6}'`
  if [ "$TEST" = "" ];then
   echo "The catalog is in the old format, re-generating the catalog..."
   $SEXTRACTOR -c `grep "SExtractor parameter file:" vast_summary.log |awk '{print $4}'` -PARAMETERS_NAME wcs.param -CATALOG_NAME $SEXTRACTOR_CATALOG_NAME -PHOT_APERTURES `lib/autodetect_aperture_main $WCS_IMAGE_NAME 2>/dev/null` $WCS_IMAGE_NAME && echo "ok"
   echo "Catalog $SEXTRACTOR_CATALOG_NAME corresponding to the image $WCS_IMAGE_NAME created."
  else
   echo "The catalog is in the new format, as expected."  
  fi
  
 fi
 #rm -f tmp$$.cat


# If we are in the star identification mode - identify the star!
if [ "$START_NAME" != "wcs_image_calibration.sh" ];then
 #while read A B C ;do
 # echo out"$A" $B $C >> tmp$$.cat
 #done < $SEXTRACTOR_CATALOG_NAME

 # Check if ucac4 plate solution is available
 UCAC4_SOLUTION_NAME="$SEXTRACTOR_CATALOG_NAME".ucac4
 if [ ! -f $UCAC4_SOLUTION_NAME ];then
  echo "Performing plate solution with UCAC4..."
  util/solve_plate_with_UCAC4 $WCS_IMAGE_NAME $FOV
  if [ $? -ne 0 ];then
   echo "ERROR matching the stars with UCAC4"
   exit 1
  fi
  if [ ! -f $UCAC4_SOLUTION_NAME ];then
   echo "ERROR: cannot find the UCAC4 plate solution file $UCAC4_SOLUTION_NAME"
   exit 1
  fi
 else
  echo "Found the UCAC4 plate solution file $UCAC4_SOLUTION_NAME"
 fi

 STARNUM=`basename $LIGHTCURVEFILE .dat`
 echo "Looking for a star near the position $X $Y (pix) in $UCAC4_SOLUTION_NAME ..."
  RADEC=`lib/find_star_in_wcs_catalog $X $Y < $UCAC4_SOLUTION_NAME`
  if [ $? -ne 0 ];then
   echo "ERROR searching for the target star in the WCS catalog $UCAC4_SOLUTION_NAME"
   exit 1
  fi
  echo " "
  echo "#########################################################################"
  echo "Star:   RA(J2000)   Dec(J2000)    X(pix)   Y(pix)   WCS_calibrated_image"
  ##################################################################################
  # Experimental feature: if you want to use spline correction for astrometry, uncomment
  # the following lines. The spline correction is useful for photographic plates
  # digitized using a flatbed scanner.
  ##################################################################################
  #RADEC_CORRECTED=`util/astrometric_correction.sh $SEXTRACTOR_CATALOG_NAME $RADEC`
  #RADEC=$RADEC_CORRECTED
  ##################################################################################
  #     00148  22:53:44.63 +16:09:08.1   283.894  280.149 wcs_3C454.3_R_20101127_0119.00027019.3C454.3.fts
  lib/deg2hms $RADEC &>/dev/null
  if [ $? -ne 0 ];then
   echo "ERROR parsing the coordinates string \"$RADEC\""
   exit 1
  fi
  echo ${STARNUM//out/" "} `lib/deg2hms $RADEC` $X $Y $WCS_IMAGE_NAME |awk '{printf "%s  %s %s  %8.3f %8.3f %s\n",$1,$2,$3,$4,$5,$6}'
  if [ "$START_NAME" = "identify_for_catalog.sh" ];then
   #rm -f tmp$$.cat
   exit 0
  fi
  echo " "
  if [ "$START_NAME" = "identify_transient.sh" ];then
   # This will stop util/search_databases_with_curl.sh from using terminal colors
   util/search_databases_with_curl.sh `lib/deg2hms $RADEC` H
   UNCALIBRATED_IMAGE_NAME=`echo ${WCS_IMAGE_NAME//"wcs_"/}`
   DATEANDTIME=`grep "$UNCALIBRATED_IMAGE_NAME" vast_image_details.log | head -n1 |awk '{print $2" "$3}'`
   util/transients/MPCheck.sh `lib/deg2hms $RADEC` $DATEANDTIME H
  else
   util/search_databases_with_curl.sh `lib/deg2hms $RADEC`
   ### Give user a chance to interrupt the script
   if [ $? -ne 0 ];then
    exit 1
   fi
   ###
   echo " "
   util/search_databases_with_vizquery.sh `lib/deg2hms $RADEC` ${STARNUM//out/" "} $FOV
   ###################################
   # If USNO-B1 identification failed, try to find this star on another image
   if [ $? -ne 0 ];then
    ####
    #if [ $? -ne 100 ];then
    # exit 1
    #fi
    ##
    echo -e "\n\nTrying to measure this star on another image... "
    tail -n1 $LIGHTCURVEFILE > lightcurve.tmp
    read JD MAG MERR X Y APP FITSFILE < lightcurve.tmp && echo "ok $FITSFILE"
    # Tesit if the original image is already a calibrated one
    TEST_SUBSTRING=`basename $FITSFILE`
    TEST_SUBSTRING="${TEST_SUBSTRING:0:4}"
    #TEST_SUBSTRING=`expr substr $TEST_SUBSTRING  1 4`
    if [ "$TEST_SUBSTRING" = "wcs_" ];then
     cp $FITSFILE .
     WCS_IMAGE_NAME=`basename $FITSFILE`
    else
     WCS_IMAGE_NAME=wcs_`basename $FITSFILE`
    fi
    SEXTRACTOR_CATALOG_NAME="$WCS_IMAGE_NAME".cat
    # Check if ucac4 plate solution is available
    UCAC4_SOLUTION_NAME="$SEXTRACTOR_CATALOG_NAME".ucac4
    if [ ! -f $UCAC4_SOLUTION_NAME ];then
     echo "Performing plate solution with UCAC4..."
     util/solve_plate_with_UCAC4 $FITSFILE $FOV
     ### Give user a chance to interrupt the script
     if [ $? -ne 0 ];then
      exit 1
     fi
     ###
    else
     echo "Found the UCAC4 plate solution file $UCAC4_SOLUTION_NAME"
    fi
    RADEC=`lib/find_star_in_wcs_catalog $X $Y < $UCAC4_SOLUTION_NAME`
    util/search_databases_with_curl.sh `lib/deg2hms $RADEC`
    ### Give user a chance to interrupt the script
    if [ $? -ne 0 ];then
     exit 1
    fi
    ###
    echo " "
    util/search_databases_with_vizquery.sh `lib/deg2hms $RADEC` ${STARNUM//out/" "}  $FOV
   fi 
   ###################################
  fi
  echo "#########################################################################"
  #rm -f tmp$$.cat 
 if [ "$START_NAME" = "identify.sh" ];then
  echo -e "The identified star is marked with the cross. Please compare the image with Aladin sky chart to make sure the identification is correct.\n"
  # Write Aladin script
  #echo "rm all; get Aladin(POSSII J,JPEG),VizieR(USNO-B1)" `lib/deg2hms $RADEC`" 1'; get Simbad " `lib/deg2hms $RADEC`" 1'; VizieR(2MASS)" `lib/deg2hms $RADEC`" 1'" > Aladin.script
  echo -n "rm all; load $WCS_IMAGE_NAME/;" `lib/deg2hms $RADEC`" ; zoom 5 arcmin ; stick ; get Aladin(POSSII J,JPEG)" `lib/deg2hms $RADEC`" ; get VizieR(USNO-B1)" `lib/deg2hms $RADEC`" 1'; get Simbad " `lib/deg2hms $RADEC`" 1'; get VizieR(2MASS)" `lib/deg2hms $RADEC`" 1' ;" > Aladin.script
  # If the star is matched with USNO-B1.0 - mark the USNO-B1.0 star in Aladin
  if [ -f search_databases_with_vizquery_USNOB_ID_OK.tmp ];then
   echo -n " draw green circle("`cat search_databases_with_vizquery_USNOB_ID_OK.tmp`" 2.5arcsec) ;" >> Aladin.script
  fi
  echo "" >> Aladin.script
  export PATH=$PATH:$HOME # Aladin is often saved in the home directory
  which Aladin &>/dev/null
  if [ $? -ne 0 ];then
   echo "Here is the Aladin script for you (copy it to Aladin console):"
   echo " "
   cat Aladin.script
   echo " "
   echo "Please note, that you may also put the Aladin executable and the Aladin.jar archive" 
   echo "into your home directory ( $HOME ) to let $0 start Aladin automatically."
  else
   echo "Aladin is starting..."
   Aladin < Aladin.script &>/dev/null &
  fi 
  echo " "
  ./pgfv $WCS_IMAGE_NAME $X $Y
 fi
fi

